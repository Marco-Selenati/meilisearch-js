const t={ALL:"all",LAST:"last"};class e extends Error{constructor(t,s,r,i){super(t),Object.setPrototypeOf(this,e.prototype),this.name="MeiliSearchCommunicationError",s instanceof Response&&(this.message=s.statusText,this.statusCode=s.status),s instanceof Error&&(this.errno=s.errno,this.code=s.code),i&&(this.stack=i,this.stack=this.stack?.replace(/(TypeError|FetchError)/,this.name),this.stack=this.stack?.replace("Failed to fetch",`request to ${r} failed, reason: connect ECONNREFUSED`),this.stack=this.stack?.replace("Not Found",`Not Found: ${r}`))}}const s=class extends Error{constructor(t,e){super(t.message),Object.setPrototypeOf(this,s.prototype),this.name="MeiliSearchApiError",this.code=t.code,this.type=t.type,this.link=t.link,this.message=t.message,this.httpStatus=e}};async function r(t){if(!t.ok){let r;try{r=await t.json()}catch(s){throw new e(t.statusText,t,t.url)}throw new s(r,t.status)}return t}function i(t,s,r){if("MeiliSearchApiError"!==t.name)throw new e(t.message,t,r,s);throw t}class o extends Error{constructor(t){super(t),Object.setPrototypeOf(this,o.prototype),this.name="MeiliSearchError"}}class n extends Error{constructor(t){super(t),Object.setPrototypeOf(this,n.prototype),this.name="MeiliSearchTimeOutError"}}function a(t){return Object.entries(t).reduce(((t,e)=>{const[s,r]=e;return void 0!==r&&(t[s]=r),t}),{})}class c{constructor(t){this.headers=function(t){const e="X-Meilisearch-Client",s="Meilisearch JavaScript (v0.30.0)";t.headers=t.headers||{};const r=Object.assign({},t.headers);if(t.apiKey&&(r.Authorization=`Bearer ${t.apiKey}`),t.headers["Content-Type"]||(r["Content-Type"]="application/json"),t.clientAgents&&Array.isArray(t.clientAgents)){const i=t.clientAgents.concat(s);r[e]=i.join(" ; ")}else{if(t.clientAgents&&!Array.isArray(t.clientAgents))throw new o(`Meilisearch: The header "${e}" should be an array of string(s).\n`);r[e]=s}return r}(t);try{const e=function(t){try{return(e=t=function(t){return t.startsWith("https://")||t.startsWith("http://")?t:`http://${t}`}(t)).endsWith("/")||(e+="/"),t=e}catch(t){throw new o("The provided host is not valid.")}var e}(t.host);this.url=new URL(e)}catch(t){throw new o("The provided host is not valid.")}}async request({method:t,url:e,params:s,body:o,config:n}){const a=new URL(e,this.url);if(s){const t=new URLSearchParams;Object.keys(s).filter((t=>null!==s[t])).map((e=>t.set(e,s[e]))),a.search=t.toString()}try{const e=await fetch(a.toString(),{...n,method:t,body:JSON.stringify(o),headers:this.headers}).then((t=>r(t)));return await e.json().catch((()=>{}))}catch(t){i(t,t.stack,a.toString())}}async get(t,e,s){return await this.request({method:"GET",url:t,params:e,config:s})}async post(t,e,s,r){return await this.request({method:"POST",url:t,body:e,params:s,config:r})}}class h{constructor(t,e){this.uid=e,this.httpRequest=new c(t)}async search(t,e,s){const r=`indexes/${this.uid}/search`;return await this.httpRequest.post(r,a({q:t,...e}),void 0,s)}async searchGet(t,e,s){const r=`indexes/${this.uid}/search`,i={q:t,...e,filter:(t=>{if("string"==typeof t)return t;if(Array.isArray(t))throw new o("The filter query parameter should be in string format when using searchGet")})(e?.filter),sort:e?.sort?.join(","),facets:e?.facets?.join(","),attributesToRetrieve:e?.attributesToRetrieve?.join(","),attributesToCrop:e?.attributesToCrop?.join(","),attributesToHighlight:e?.attributesToHighlight?.join(",")};return await this.httpRequest.get(r,a(i),s)}}class u{constructor(t){this.config=t}index(t){return new h(this.config,t)}}class l extends u{constructor(t){super(t)}}export{h as Index,t as MatchingStrategies,l as MeiliSearch,s as MeiliSearchApiError,e as MeiliSearchCommunicationError,o as MeiliSearchError,n as MeiliSearchTimeOutError,l as default,i as httpErrorHandler,r as httpResponseErrorHandler};
//# sourceMappingURL=meilisearch.esm.min.js.map
